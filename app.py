# app.py - Cognitbotz AI Legal Platform - Legal Research & Document Drafting

import streamlit as st
import time
import os
import tempfile
import shutil
from pathlib import Path
from typing import Optional
from vectors import EmbeddingsManager  
from chatbot import ChatbotManager
from legal_drafting import LegalDraftingManager
from dotenv import load_dotenv, find_dotenv
import sqlite3
from datetime import datetime
import uuid
import logging
import atexit

# PDF and DOCX generation libraries
from io import BytesIO
try:
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.lib.enums import TA_JUSTIFY, TA_LEFT, TA_CENTER
    REPORTLAB_AVAILABLE = True
except ImportError:
    REPORTLAB_AVAILABLE = False
    
try:
    from docx import Document as DocxDocument
    from docx.shared import Inches, Pt, RGBColor
    from docx.enum.text import WD_ALIGN_PARAGRAPH
    DOCX_AVAILABLE = True
except ImportError:
    DOCX_AVAILABLE = False

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('Cognitbotz.log')
    ]
)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv(find_dotenv())

# Cognitbotz Configuration - Enhanced Limits
MAX_FILE_SIZE = 25 * 1024 * 1024  # 25MB
ALLOWED_EXTENSIONS = ['pdf', 'txt', 'docx', 'pptx']
MAX_INTERACTIONS_PER_SESSION = 50  # Increased from 25
MAX_TOKENS_PER_SESSION = 100000  # Increased from 75000
TOKEN_WARNING_THRESHOLDS = [30000, 60000, 85000]

# PDF Generation Function
def generate_pdf(content: str, doc_type: str, metadata: dict) -> Optional[BytesIO]:
    """Generate professional PDF from document content"""
    if not REPORTLAB_AVAILABLE:
        return None
    
    # These imports are guaranteed to be available since REPORTLAB_AVAILABLE is True
    from reportlab.lib.pagesizes import letter
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.lib.enums import TA_JUSTIFY, TA_LEFT, TA_CENTER
    from reportlab.lib.colors import black, gray
    
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter, 
                           rightMargin=72, leftMargin=72,
                           topMargin=72, bottomMargin=18)
    
    styles = getSampleStyleSheet()
    
    # Custom styles for legal documents
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=16,
        textColor=black,
        spaceAfter=30,
        alignment=TA_CENTER,
        fontName='Helvetica-Bold'
    )
    
    heading_style = ParagraphStyle(
        'CustomHeading',
        parent=styles['Heading2'],
        fontSize=12,
        textColor=black,
        spaceAfter=12,
        spaceBefore=12,
        fontName='Helvetica-Bold'
    )
    
    body_style = ParagraphStyle(
        'CustomBody',
        parent=styles['BodyText'],
        fontSize=11,
        alignment=TA_JUSTIFY,
        spaceAfter=12,
        fontName='Times-Roman',
        leading=14
    )
    
    story = []
    
    # Add title
    story.append(Paragraph(doc_type.upper(), title_style))
    story.append(Spacer(1, 0.2*inch))
    
    # Add metadata
    metadata_text = f"<b>Generated:</b> {metadata.get('generated_at', 'N/A')}<br/>"
    metadata_text += f"<b>Jurisdiction:</b> {metadata.get('jurisdiction', 'General')}"
    story.append(Paragraph(metadata_text, body_style))
    story.append(Spacer(1, 0.3*inch))
    
    # Process content
    lines = content.split('\n')
    for line in lines:
        line = line.strip()
        if not line:
            story.append(Spacer(1, 0.1*inch))
            continue
        
        # Detect headings (all caps or starts with numbers)
        if line.isupper() and len(line) < 100:
            story.append(Paragraph(line, heading_style))
        elif line.startswith(('1.', '2.', '3.', '4.', '5.', 'Article', 'Section')):
            story.append(Paragraph(f"<b>{line}</b>", body_style))
        else:
            story.append(Paragraph(line, body_style))
    
    # Add Cognitbotz footer
    story.append(Spacer(1, 0.5*inch))
    footer_text = "<i>This document was generated by Cognitbotz AI Legal Platform. " \
                 "Please review with qualified legal counsel before use.</i>"
    story.append(Paragraph(footer_text, ParagraphStyle(
        'Footer',
        parent=styles['Normal'],
        fontSize=8,
        textColor=gray,
        alignment=TA_CENTER
    )))
    
    doc.build(story)
    buffer.seek(0)
    return buffer

def generate_docx(content: str, doc_type: str, metadata: dict) -> Optional[BytesIO]:
    """Generate professional DOCX from document content"""
    if not DOCX_AVAILABLE:
        return None
    
    # These imports are guaranteed to be available since DOCX_AVAILABLE is True
    from docx import Document as DocxDocument
    from docx.shared import Pt, RGBColor
    from docx.enum.text import WD_ALIGN_PARAGRAPH
    
    doc = DocxDocument()
    
    # Set document properties
    core_props = doc.core_properties
    core_props.title = doc_type
    core_props.author = "Cognitbotz AI Legal Platform"
    core_props.comments = f"Generated on {metadata.get('generated_at', 'N/A')}"
    
    # Add title
    title = doc.add_heading(doc_type.upper(), 0)
    title.alignment = WD_ALIGN_PARAGRAPH.CENTER
    
    # Add metadata section
    doc.add_paragraph()
    meta_para = doc.add_paragraph()
    meta_para.add_run('Generated: ').bold = True
    meta_para.add_run(metadata.get('generated_at', 'N/A'))
    meta_para.add_run('\nJurisdiction: ').bold = True
    meta_para.add_run(metadata.get('jurisdiction', 'General'))
    
    doc.add_paragraph()
    doc.add_paragraph('_' * 80)
    doc.add_paragraph()
    
    # Process content
    lines = content.split('\n')
    for line in lines:
        line = line.strip()
        if not line:
            doc.add_paragraph()
            continue
        
        # Detect headings
        if line.isupper() and len(line) < 100:
            heading = doc.add_heading(line, level=2)
            heading.runs[0].font.color.rgb = RGBColor(30, 58, 138)
        elif line.startswith(('1.', '2.', '3.', '4.', '5.', 'Article', 'Section')):
            para = doc.add_paragraph(line)
            para.runs[0].bold = True
        else:
            para = doc.add_paragraph(line)
            para.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
    
    # Add Cognitbotz footer
    doc.add_paragraph()
    doc.add_paragraph('_' * 80)
    footer = doc.add_paragraph()
    footer_run = footer.add_run(
        'This document was generated by Cognitbotz AI Legal Platform. '
        'Please review with qualified legal counsel before use.'
    )
    footer_run.italic = True
    footer_run.font.size = Pt(9)
    footer_run.font.color.rgb = RGBColor(128, 128, 128)
    footer.alignment = WD_ALIGN_PARAGRAPH.CENTER
    
    # Save to BytesIO
    buffer = BytesIO()
    doc.save(buffer)
    buffer.seek(0)
    return buffer

def validate_file_path(file_path):
    """SECURITY: Validate file path"""
    if file_path is None or not file_path.strip():
        return False, "No file path provided"
    
    if not os.path.exists(file_path):
        return False, "File not found"
    
    # Get file size
    file_size = os.path.getsize(file_path)
    if file_size > MAX_FILE_SIZE:
        return False, f"File too large. Max: {MAX_FILE_SIZE // (1024*1024)}MB"
    
    file_extension = os.path.splitext(file_path)[1][1:].lower()
    if file_extension not in ALLOWED_EXTENSIONS:
        return False, f"File type not allowed. Allowed: {', '.join(ALLOWED_EXTENSIONS)}"
    
    if any(char in file_path for char in ['<', '>', '..\\', '../']):
        return False, "Invalid characters in file path"
    
    return True, "Valid file"

def log_interaction(session_id, component, user_input, bot_response, tokens_used, is_flagged=False, flag_reason=None):
    """Enhanced Cognitbotz logging with component tracking"""
    conn = None
    try:
        conn = sqlite3.connect("Cognitbotz_logs.db", timeout=10)
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS legal_interactions (
                id TEXT PRIMARY KEY,
                session_id TEXT,
                component TEXT,
                timestamp TEXT,
                user_input TEXT,
                bot_response TEXT,
                tokens_used INTEGER,
                is_flagged BOOLEAN,
                flag_reason TEXT
            )
        """)
        cursor.execute("""
            INSERT INTO legal_interactions (id, session_id, component, timestamp, user_input, bot_response, tokens_used, is_flagged, flag_reason)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            str(uuid.uuid4()),
            session_id,
            component,
            datetime.now().isoformat(),
            user_input[:1000],
            bot_response[:15000],
            tokens_used,
            is_flagged,
            flag_reason
        ))
        conn.commit()
    except Exception as e:
        logger.error(f"Failed to log interaction: {e}")
    finally:
        if conn:
            try:
                conn.close()
            except:
                pass

# Page configuration
st.set_page_config(
    page_title="Cognitbotz AI Legal Platform",
    page_icon="‚öñÔ∏è",
    layout="wide",
    initial_sidebar_state="expanded",
)

# Enhanced Cognitbotz CSS
st.markdown("""
<style>
    .main { padding-top: 1rem; }
    
    /* Cognitbotz Gradient Headers */
    .component-header {
        background: linear-gradient(90deg, #1e3a8a 0%, #3730a3 100%);
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 0.5rem;
        margin-bottom: 1rem;
        font-size: 1.2rem;
        font-weight: bold;
    }
    
    /* Legal-themed messages */
    .legal-message { 
        padding: 1rem; 
        margin: 0.5rem 0; 
        border-radius: 0.5rem; 
        border-left: 4px solid #059669;
        background-color: #f0fdf4;
    }
    .user-message { 
        background-color: #eff6ff; 
        border-left-color: #2563eb; 
        margin-left: 10%;
    }
    .assistant-message { 
        background-color: #f9fafb; 
        border-left-color: #059669; 
        margin-right: 10%;
    }
    
    /* Enhanced Document Preview */
    .doc-preview {
        background-color: #ffffff;
        border: 2px solid #e5e7eb;
        border-radius: 0.75rem;
        padding: 2rem;
        margin: 1rem 0;
        max-height: 600px;
        overflow-y: auto;
        font-family: 'Times New Roman', serif;
        line-height: 1.6;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    .doc-preview h1, .doc-preview h2, .doc-preview h3 {
        color: #1e3a8a;
        margin-top: 1.5rem;
        margin-bottom: 0.75rem;
    }
    
    .doc-preview p {
        text-align: justify;
        margin-bottom: 1rem;
    }
    
    /* Download section styling */
    .download-section {
        background-color: #f3f4f6;
        padding: 1rem;
        border-radius: 0.5rem;
        margin: 1rem 0;
    }
    
    /* Response badges */
    .response-badge {
        display: inline-block;
        padding: 0.25rem 0.75rem;
        border-radius: 0.25rem;
        font-size: 0.85rem;
        font-weight: bold;
        margin-bottom: 0.5rem;
    }
    .badge-rag {
        background-color: #3b82f6;
        color: white;
    }
    .badge-general {
        background-color: #10b981;
        color: white;
    }
    .badge-hybrid {
        background-color: #8b5cf6;
        color: white;
    }
    .badge-layman {
        background-color: #f59e0b;
        color: white;
    }
    
    /* Source info styling */
    .source-info {
        background-color: #f8f9fa;
        padding: 0.5rem;
        border-radius: 0.3rem;
        margin: 0.2rem 0;
        font-size: 0.85rem;
        border-left: 3px solid #059669;
    }
    
    /* Token warnings */
    .token-warning-low {
        background-color: #fff3cd;
        border: 1px solid #ffeaa7;
        padding: 0.5rem;
        border-radius: 0.3rem;
        color: #856404;
    }
    .token-warning-medium {
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
        padding: 0.5rem;
        border-radius: 0.3rem;
        color: #721c24;
    }
    .token-warning-high {
        background-color: #d1ecf1;
        border: 1px solid #bee5eb;
        padding: 0.5rem;
        border-radius: 0.3rem;
        color: #0c5460;
        font-weight: bold;
    }
</style>
""", unsafe_allow_html=True)

# Session state initialization
def initialize_session_state():
    """Initialize Cognitbotz session state"""
    defaults = {
        'temp_file_paths': [],
        'session_id': str(uuid.uuid4()),
        'files_processed': False,
        'embeddings_saved': False,
        'chatbot_manager': None,
        'drafting_manager': None,
        'messages': [],
        'drafted_documents': [],
        'last_generated_doc': None,
        'document_info': {},
        'processing': False,
        'interaction_count': 0,
        'total_tokens_used': 0,
        'last_query_tokens': 0,
        'input_tokens_used': 0,
        'output_tokens_used': 0,
        'error_count': 0,
        'embeddings_manager': None,
        'collection_created': False,
        'qdrant_collection_name': None,
        'processed_files': [],
        'token_warnings_shown': [],
        'user_preferences': {}
    }
    
    for key, value in defaults.items():
        if key not in st.session_state:
            st.session_state[key] = value

def show_token_warning(tokens_used):
    """Show progressive token warnings"""
    percentage = (tokens_used / MAX_TOKENS_PER_SESSION) * 100
    
    if tokens_used >= TOKEN_WARNING_THRESHOLDS[2] and 'high' not in st.session_state['token_warnings_shown']:
        st.markdown(f"""
        <div class="token-warning-high">
        ‚ö†Ô∏è <strong>CRITICAL:</strong> You've used {tokens_used:,} tokens ({percentage:.1f}% of limit). 
        Only a few queries remaining before session reset required.
        </div>
        """, unsafe_allow_html=True)
        st.session_state['token_warnings_shown'].append('high')
        
    elif tokens_used >= TOKEN_WARNING_THRESHOLDS[1] and 'medium' not in st.session_state['token_warnings_shown']:
        st.markdown(f"""
        <div class="token-warning-medium">
        ‚ö†Ô∏è <strong>WARNING:</strong> You've used {tokens_used:,} tokens ({percentage:.1f}% of limit). 
        Consider wrapping up your current task soon.
        </div>
        """, unsafe_allow_html=True)
        st.session_state['token_warnings_shown'].append('medium')
        
    elif tokens_used >= TOKEN_WARNING_THRESHOLDS[0] and 'low' not in st.session_state['token_warnings_shown']:
        st.markdown(f"""
        <div class="token-warning-low">
        ‚ÑπÔ∏è <strong>NOTICE:</strong> You've used {tokens_used:,} tokens ({percentage:.1f}% of limit).
        </div>
        """, unsafe_allow_html=True)
        st.session_state['token_warnings_shown'].append('low')

# Initialize session state
initialize_session_state()

# Header
st.title("‚öñÔ∏è Cognitbotz AI Legal Platform")
st.markdown("**Intelligent Legal Research & Document Drafting**")

# Create tabs
tab1, tab2 = st.tabs(["üìö Legal Research", "üìù Legal Drafting"])

# ============================================================================
# TAB 1: LEGAL RESEARCH
# ============================================================================
with tab1:
    # Sidebar configuration
    with st.sidebar:
        st.markdown("### ‚öñÔ∏è Cognitbotz Legal AI")
        st.markdown("**HYBRID MODE** üéØ")
        st.markdown("*Intelligent legal research and analysis*")
        st.markdown("---")
        
        # USER PREFERENCES SECTION
        st.markdown("### üë§ User Preferences")
        jurisdiction = st.selectbox(
            "Jurisdiction",
            ["General", "United States", "United Kingdom", "European Union", "India", "Canada", "Australia"],
            help="Select your legal jurisdiction"
        )
        
        practice_area = st.selectbox(
            "Practice Area",
            ["General Practice", "Constitutional Law", "Contract Law", "Corporate Law", 
             "Criminal Law", "Family Law", "IP Law", "Tax Law", "Employment Law"],
            help="Select your area of legal practice"
        )
        
        citation_style = st.selectbox(
            "Citation Style",
            ["Bluebook", "ALWD", "Chicago", "APA"],
            help="Preferred citation format"
        )
        
        # Store user preferences
        st.session_state['user_preferences'] = {
            'jurisdiction': jurisdiction,
            'practice_area': practice_area,
            'citation_style': citation_style
        }
        
        st.markdown("---")
        
        # LLM Configuration
        st.markdown("### ü§ñ LLM Configuration")
        
        llm_source = st.radio(
            "LLM Source",
            options=["‚òÅÔ∏è External (Groq)", "üè¢ Custom/Internal Model"],
            index=0
        )
        
        use_custom_llm = (llm_source == "üè¢ Custom/Internal Model")
        
        if use_custom_llm:
            with st.expander("üè¢ Custom LLM Settings", expanded=True):
                custom_llm_url = st.text_input(
                    "API Endpoint",
                    value=os.getenv('CUSTOM_LLM_URL', 'http://localhost:8000/v1'),
                    placeholder="http://your-server:8000/v1"
                )
                custom_llm_api_key = st.text_input(
                    "API Key (optional)",
                    value=os.getenv('CUSTOM_LLM_API_KEY', ''),
                    type="password"
                )
                custom_llm_model_name = st.text_input(
                    "Model Name",
                    value=os.getenv('CUSTOM_LLM_MODEL', 'company-model'),
                    placeholder="model-name"
                )
        else:
            custom_llm_url = None
            custom_llm_api_key = None
            custom_llm_model_name = None
        
        st.divider()
        
        # Model Settings
        with st.expander("ü§ñ Model Settings", expanded=True):
            llm_model = st.selectbox(
                "LLM Model",
                ["llama-3.3-70b-versatile", "llama-3.1-70b-versatile", "mixtral-8x7b-32768"],
                index=0
            )
            
            temperature = st.slider("Temperature", 0.0, 1.0, 0.3, 0.1)
            max_tokens = st.slider("Max Tokens", 512, 8000, 4000, 512)
        
        # Retrieval Settings
        with st.expander("üîç Retrieval Settings"):
            retrieval_k = st.slider("Retrieved Chunks", 3, 15, 8)
            score_threshold = st.slider("Relevance Threshold", 0.0, 1.0, 0.4, 0.05)
        
        # Safety & Compliance
        with st.expander("üõ°Ô∏è Safety & Compliance"):
            enable_content_filter = st.checkbox("Content Filter", value=True)
            enable_pii_detection = st.checkbox("PII Detection", value=True)
            max_interactions = st.number_input(
                "Max Interactions",
                min_value=10,
                max_value=MAX_INTERACTIONS_PER_SESSION,
                value=MAX_INTERACTIONS_PER_SESSION
            )
        
        # Chatbot Mode
        with st.expander("ü§ñ Response Mode"):
            chatbot_mode = st.radio(
                "Mode",
                options=["Document Only (RAG)", "General Chat (No RAG)", "Layman"],
                index=0,
                help="Document Only uses information from uploaded documents. General Chat uses general knowledge. Layman mode provides easy-to-understand explanations."
            )
        
        st.divider()
        
        # Legal Document Path - REMOVED FROM UI AS REQUESTED
        # Specify document paths directly
        document_paths = [
            "legal_documents/COI.pdf",
            "legal_documents/BNS.pdf",
            #"legal_documents/BNSS.pdf",
            #"legal_documents/BSA.pdf"
        ]
        
        # Filter to only include documents that exist
        existing_documents = [path for path in document_paths if os.path.exists(path)]
        
        if existing_documents and not st.session_state.get('collection_created') and not st.session_state.processing:
            with st.spinner(f"Processing {len(existing_documents)} legal documents... This may take several minutes for large documents."):
                st.session_state['processing'] = True
                
                try:
                    # Initialize Embeddings with settings optimized for large legal documents
                    current_collection = f"legal_docs_{st.session_state['session_id'][:8]}"
                    embeddings_manager = EmbeddingsManager(
                        model_name="BAAI/bge-small-en",
                        device="cpu",
                        encode_kwargs={"normalize_embeddings": True},
                        qdrant_url=os.getenv('QDRANT_URL') or "https://default-qdrant-url.com",
                        collection_name=current_collection,
                        chunk_size=500,  # Even smaller chunks
                        chunk_overlap=100,  # Reduced overlap
                        max_chunks=1000  # Limit chunks for testing
                    )
                    
                    # Process each PDF file
                    processed_files = []
                    for file_path in existing_documents:
                        # Validate file path
                        is_valid, message = validate_file_path(file_path)
                        if not is_valid:
                            logger.warning(f"File validation failed for {file_path}: {message}")
                            st.warning(f"‚ö†Ô∏è File validation failed for {file_path}: {message}")
                            continue
                        
                        # Get just the filename for display
                        filename = os.path.basename(file_path)
                        
                        # Process file
                        result = embeddings_manager.create_embeddings(file_path)
                        processed_files.append(filename)
                        st.session_state['processed_files'].append(filename)
                        
                        # Show processing result
                        logger.info(f"Document processing result for {filename}: {result}")
                        st.info(f"‚úÖ {filename} processed successfully!")
                
                    if processed_files:
                        # Initialize Chatbot with settings optimized for legal documents
                        chatbot_manager = ChatbotManager(
                            model_name="BAAI/bge-small-en",
                            device="cpu",
                            encode_kwargs={"normalize_embeddings": True},
                            llm_model=llm_model,
                            llm_temperature=temperature,
                            max_tokens=max_tokens,
                            qdrant_url=os.getenv('QDRANT_URL') or "https://default-qdrant-url.com",
                            collection_name=current_collection,
                            retrieval_k=10,  # Reduced for testing
                            score_threshold=0.2,  # Increased threshold
                            use_custom_llm=use_custom_llm,
                            custom_llm_url=custom_llm_url,
                            custom_llm_api_key=custom_llm_api_key,
                            custom_llm_model_name=custom_llm_model_name
                        )
                        st.session_state['chatbot_manager'] = chatbot_manager
                        st.session_state['collection_created'] = True
                        
                        logger.info(f"Successfully processed {len(processed_files)} documents: {', '.join(processed_files)}")
                        st.success(f"‚úÖ Successfully processed {len(processed_files)} legal documents: {', '.join(processed_files)}")
                    else:
                        st.warning("‚ö†Ô∏è No documents were successfully processed.")
                    
                    st.session_state['processing'] = False
                    
                except Exception as e:
                    st.session_state['processing'] = False
                    st.session_state['error_count'] += 1
                    logger.error(f"Failed to process documents: {e}")
                    logger.error(f"Full traceback: ", exc_info=True)
                    st.error(f"‚ùå Failed to process documents: {str(e)}")
        elif not existing_documents:
            logger.info("No legal documents found in the specified paths")
            st.info("No legal documents found in the specified paths. Please check the document paths.")

    # Main Chat Interface
    st.markdown('<div class="component-header">üí¨ Legal Research Chat</div>', unsafe_allow_html=True)

    # Check limits
    tokens_used = st.session_state.get('total_tokens_used', 0)
    if st.session_state.interaction_count >= max_interactions:
        st.warning(f"‚ö†Ô∏è Maximum interactions ({max_interactions}) reached. Please reset session.")
    elif tokens_used >= MAX_TOKENS_PER_SESSION:
        st.error(f"üö´ Token limit reached ({tokens_used:,}/{MAX_TOKENS_PER_SESSION:,}). Please reset session.")
    elif not st.session_state.get('collection_created') and len(st.session_state.get('messages', [])) == 0:
        # Welcome screen
        st.info("üëÜ Enter the path to a legal document to begin research, or start chatting in General mode!")
        
        st.markdown("---")
        st.markdown("**üí° Getting Started:**")
        st.markdown("- Enter the path to a legal document to enable document-based research")
        st.markdown("- Switch to General Chat mode for questions without documents")
        st.markdown("- Try Layman mode for easy-to-understand explanations")
        
    else:
        # Display chat messages
        if st.session_state['messages']:
            for msg in st.session_state['messages']:
                if msg['role'] == 'user':
                    st.markdown(f"""
                    <div class="legal-message user-message">
                        <strong>üë§ You:</strong><br>{msg['content']}
                    </div>
                    """, unsafe_allow_html=True)
                else:
                    # Show response type badge
                    response_type = msg.get('response_type', 'rag')
                    if response_type == 'rag':
                        badge_html = '<span class="response-badge badge-rag">üìö FROM DOCUMENTS (Professional)</span>'
                    elif response_type == 'general_knowledge':
                        badge_html = '<span class="response-badge badge-general">üß† GENERAL KNOWLEDGE (Simple Explanation)</span>'
                    elif response_type == 'layman':
                        badge_html = '<span class="response-badge badge-general">üë®‚Äç‚öñÔ∏è LAYMAN (Easy to Understand)</span>'
                    else:
                        badge_html = '<span class="response-badge badge-hybrid">üéØ HYBRID</span>'
                    
                    # For layman responses, preserve markdown formatting
                    if response_type == 'layman':
                        st.markdown(f"""
                        <div class="legal-message assistant-message">
                            {badge_html}
                            <strong>‚öñÔ∏è Cognitbotz:</strong>
                        </div>
                        """, unsafe_allow_html=True)
                        # Render the content with markdown
                        st.markdown(msg['content'])
                    else:
                        st.markdown(f"""
                        <div class="legal-message assistant-message">
                            {badge_html}
                            <strong>‚öñÔ∏è Cognitbotz:</strong><br>{msg['content']}
                        </div>
                        """, unsafe_allow_html=True)
                    
                    if msg.get('is_flagged'):
                        st.warning(f"‚ö†Ô∏è Content filtered: {msg.get('flag_reason', 'Unknown')}")
                    
                    if msg.get('tokens_used'):
                        st.caption(f"üî¢ Tokens used: ~{msg['tokens_used']:,}")
                    
                    if msg.get('sources') and len(msg.get('sources', [])) > 0:
                        with st.expander(f"üìö Sources ({len(msg['sources'])})"):
                            for i, source in enumerate(msg['sources'], 1):
                                st.markdown(f"""
                                <div class="source-info">
                                <strong>Source {i}:</strong> {source.get('file_name', 'Unknown')} 
                                (Page {source.get('page', 'N/A')})
                                </div>
                                """, unsafe_allow_html=True)
        else:
            st.info("üéØ Start your legal research by asking questions below!")
        
        # Initialize chatbot for general chat if needed
        if chatbot_mode in ["General Chat (No RAG)", "Layman"] and not st.session_state.get('chatbot_manager'):
            try:
                temp_collection = f"temp_{st.session_state['session_id'][:8]}"
                
                chatbot_manager = ChatbotManager(
                    model_name="BAAI/bge-small-en",
                    device="cpu",
                    encode_kwargs={"normalize_embeddings": True},
                    llm_model=llm_model,
                    llm_temperature=temperature,
                    max_tokens=max_tokens,
                    qdrant_url=os.getenv('QDRANT_URL') or "https://default-qdrant-url.com",
                    collection_name=temp_collection,
                    retrieval_k=retrieval_k,
                    score_threshold=score_threshold,
                    use_custom_llm=use_custom_llm,
                    custom_llm_url=custom_llm_url,
                    custom_llm_api_key=custom_llm_api_key,
                    custom_llm_model_name=custom_llm_model_name
                )
                st.session_state['chatbot_manager'] = chatbot_manager
                st.success("‚úÖ General Chat Ready!")
            except Exception as e:
                logger.error(f"Failed to initialize: {e}")

    # Chat input
    can_chat = (
        st.session_state.interaction_count < max_interactions and 
        tokens_used < MAX_TOKENS_PER_SESSION and
        (st.session_state.get('collection_created') or chatbot_mode in ["General Chat (No RAG)", "Layman"])
    )

    if can_chat:
        user_input = st.chat_input("Ask your legal questions...")
        
        if user_input:
            st.session_state.interaction_count += 1
            
            with st.spinner("ü§î Conducting legal research..."):
                try:
                    if not st.session_state.get('chatbot_manager'):
                        temp_collection = f"temp_{st.session_state['session_id'][:8]}"
                        chatbot_manager = ChatbotManager(
                            model_name="BAAI/bge-small-en",
                            device="cpu",
                            encode_kwargs={"normalize_embeddings": True},
                            llm_model=llm_model,
                            llm_temperature=temperature,
                            max_tokens=max_tokens,
                            qdrant_url=os.getenv('QDRANT_URL') or "https://default-qdrant-url.com",
                            collection_name=temp_collection,
                            retrieval_k=retrieval_k,
                            score_threshold=score_threshold,
                            use_custom_llm=use_custom_llm,
                            custom_llm_url=custom_llm_url,
                            custom_llm_api_key=custom_llm_api_key,
                            custom_llm_model_name=custom_llm_model_name
                        )
                        st.session_state['chatbot_manager'] = chatbot
                    
                    # Determine RAG usage
                    use_rag = True
                    if chatbot_mode == "General Chat (No RAG)":
                        use_rag = False
                    elif chatbot_mode == "Document Only (RAG)":
                        use_rag = True
                    elif chatbot_mode == "Layman":
                        use_rag = st.session_state.get('collection_created', False)  # Use RAG if documents available, otherwise general knowledge
                    
                    # Determine if layman mode is enabled
                    layman_mode = (chatbot_mode == "Layman")
                    
                    response_data = st.session_state['chatbot_manager'].get_response(
                        user_input,
                        enable_content_filter=enable_content_filter,
                        enable_pii_detection=enable_pii_detection,
                        use_rag=use_rag,
                        layman_mode=layman_mode
                    )
                    
                    tokens_used = response_data.get('tokens_used', 0)
                    input_tokens = response_data.get('input_tokens', 0)
                    output_tokens = response_data.get('output_tokens', 0)
                    
                    st.session_state.total_tokens_used += tokens_used
                    st.session_state.input_tokens_used += input_tokens
                    st.session_state.output_tokens_used += output_tokens
                    
                    st.session_state['messages'].append({
                        "role": "user", 
                        "content": user_input
                    })
                    st.session_state['messages'].append({
                        "role": "assistant",
                        "content": response_data.get('answer', 'No response generated'),
                        "sources": response_data.get('sources', []),
                        "is_flagged": response_data.get('is_flagged', False),
                        "flag_reason": response_data.get('flag_reason'),
                        "tokens_used": tokens_used,
                        "response_type": response_data.get('response_type', 'rag')
                    })
                    
                    log_interaction(
                        session_id=st.session_state['session_id'],
                        component='research',
                        user_input=user_input,
                        bot_response=response_data.get('answer', ''),
                        tokens_used=tokens_used,
                        is_flagged=response_data.get('is_flagged', False),
                        flag_reason=response_data.get('flag_reason')
                    )
                    
                except Exception as e:
                    st.session_state['error_count'] += 1
                    logger.error(f"Chat error: {e}")
                    st.error(f"‚ùå Error: {str(e)}")
            
            st.rerun()

# ============================================================================
# TAB 2: LEGAL DRAFTING
# ============================================================================
with tab2:
    st.markdown('<div class="component-header">‚úèÔ∏è Legal Document Drafting</div>', unsafe_allow_html=True)
    
    # Initialize drafting manager
    if not st.session_state.get('drafting_manager'):
        try:
            drafting_manager = LegalDraftingManager(
                llm_model=llm_model,
                temperature=0.3,
                max_tokens=12000,
                user_preferences=st.session_state.get('user_preferences', {})
            )
            st.session_state['drafting_manager'] = drafting_manager
        except Exception as e:
            st.error(f"‚ùå Failed to initialize drafting: {e}")
            st.stop()
    
    # Document configuration
    col1, col2 = st.columns(2)
    
    with col1:
        doc_type = st.selectbox(
            "Document Type",
            [
                "Contracts & Agreements",
                "Petitions & Applications",
                "Court Orders & Judgments",
                "Legal Briefs & Submissions",
                "Statutes & Regulations"
            ]
        )
        
        draft_style = st.selectbox(
            "Drafting Style",
            ["Formal Legal", "Plain English", "Business Formal", "Technical", "Academic Legal"],
            help="Choose the writing style"
        )
    
    with col2:
        document_length = st.selectbox(
            "Document Length",
            ["Brief", "Short (1-2 pages)", "Standard", "Medium (3-5 pages)", "Comprehensive", "Long (6-10 pages)", "Detailed"],
            help="Select desired document length"
        )
        
        # Optional clauses
        available_clauses = [
            "Definitions", "Parties", "Recitals", "Terms and Conditions",
            "Representations", "Warranties", "Limitations", "Indemnification",
            "Confidentiality", "Termination", "Dispute Resolution", "Governing Law"
        ]
        selected_clauses = st.multiselect("Include Clauses (optional)", available_clauses)
    
    # Special provisions
    special_provisions = st.text_area(
        "Special Provisions (Optional):",
        placeholder="Any special terms, conditions, or provisions...",
        height=100,
        help="Add specific requirements or provisions"
    )
    
    # Main drafting requirements
    st.markdown("### üìù Document Requirements")
    requirements = st.text_area(
        "Describe what you want to draft:",
        height=200,
        placeholder="Example: Draft a service agreement between Company A and Company B for software development services. Include payment terms of $10,000 per month, 6-month initial term, confidentiality obligations...",
        help="Provide detailed requirements"
    )
    
    # Generate and clear buttons
    col1, col2, col3 = st.columns([1, 1, 2])
    
    with col1:
        generate_btn = st.button("‚ú® Generate Document", type="primary", use_container_width=True)
    
    with col2:
        if st.session_state.get('last_generated_doc'):
            if st.button("üóëÔ∏è Clear Document", type="secondary", use_container_width=True):
                st.session_state['last_generated_doc'] = None
                st.rerun()
    
    # Generate document
    if generate_btn:
        if not requirements.strip():
            st.warning("‚ö†Ô∏è Please provide document requirements")
        else:
            with st.spinner("‚úèÔ∏è Drafting your legal document..."):
                try:
                    result = st.session_state['drafting_manager'].generate_document(
                        doc_type=doc_type,
                        prompt=requirements,
                        style=draft_style,
                        length=document_length,
                        clauses=selected_clauses if selected_clauses else None,
                        special_provisions=special_provisions if special_provisions else ""
                    )
                    
                    if 'error' not in result:
                        st.session_state['last_generated_doc'] = result
                        st.session_state.drafted_documents.append(result)
                        st.session_state.total_tokens_used += result.get('tokens_used', 0)
                        
                        log_interaction(
                            st.session_state.session_id,
                            'drafting',
                            requirements,
                            result.get('document', '')[:1000],
                            result.get('tokens_used', 0)
                        )
                        
                        st.success(f"‚úÖ Document generated! ({result.get('word_count', 0)} words, {result.get('tokens_used', 0)} tokens)")
                        st.rerun()
                    else:
                        st.error(f"‚ùå Generation failed: {result['error']}")
                
                except Exception as e:
                    logger.error(f"Drafting error: {e}")
                    st.error(f"‚ùå Error: {str(e)}")
    
    # Display generated document
    if st.session_state.get('last_generated_doc'):
        draft_result = st.session_state['last_generated_doc']
        
        st.markdown("---")
        st.markdown("### üìÑ Generated Legal Document")
        
        # Document metadata
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("üìã Type", draft_result.get('doc_type', 'N/A'))
        with col2:
            st.metric("‚úçÔ∏è Style", draft_result.get('style', 'N/A'))
        with col3:
            st.metric("üìù Words", draft_result.get('word_count', 0))
        with col4:
            st.metric("üéØ Tokens", draft_result.get('tokens_used', 0))
        
        # Document preview
        st.markdown('<div class="doc-preview">', unsafe_allow_html=True)
        doc_content = draft_result.get('document', 'No document generated')
        
        # Better formatting: Split into lines and handle sections properly
        lines = doc_content.split('\n')
        formatted_lines = []
        
        for line in lines:
            line = line.strip()
            if not line:
                formatted_lines.append('<br>')  # Empty line
            elif line.isupper() and len(line) < 100:
                # All caps likely a heading
                formatted_lines.append(f'<h3 style="color: #1e3a8a; margin-top: 1.5rem;">{line}</h3>')
            elif line.startswith(('1.', '2.', '3.', '4.', '5.', 'Article', 'Section', 'Clause')):
                # Numbered sections or articles
                formatted_lines.append(f'<p style="margin-top: 1rem;"><strong>{line}</strong></p>')
            else:
                # Regular paragraph
                formatted_lines.append(f'<p style="text-align: justify; margin-bottom: 0.5rem;">{line}</p>')
        
        formatted_content = '\n'.join(formatted_lines)
        st.markdown(formatted_content, unsafe_allow_html=True)
        st.markdown('</div>', unsafe_allow_html=True)
        
        # Download section
        st.markdown('<div class="download-section">', unsafe_allow_html=True)
        st.markdown("### üì• Download Options")
        
        col1, col2, col3, col4 = st.columns(4)
        
        # TXT download
        with col1:
            st.download_button(
                label="üìÑ Download TXT",
                data=draft_result['document'],
                file_name=f"{doc_type.lower().replace(' ', '_').replace('&', 'and')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
                mime="text/plain",
                use_container_width=True
            )
        
        # PDF download
        with col2:
            if REPORTLAB_AVAILABLE:
                pdf_buffer = generate_pdf(
                    draft_result['document'],
                    draft_result['doc_type'],
                    draft_result.get('metadata', {})
                )
                if pdf_buffer:
                    st.download_button(
                        label="üìï Download PDF",
                        data=pdf_buffer,
                        file_name=f"{doc_type.lower().replace(' ', '_').replace('&', 'and')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf",
                        mime="application/pdf",
                        use_container_width=True
                    )
            else:
                st.button("üìï PDF (Install reportlab)", disabled=True, use_container_width=True)
        
        # DOCX download
        with col3:
            if DOCX_AVAILABLE:
                docx_buffer = generate_docx(
                    draft_result['document'],
                    draft_result['doc_type'],
                    draft_result.get('metadata', {})
                )
                if docx_buffer:
                    st.download_button(
                        label="üìò Download DOCX",
                        data=docx_buffer,
                        file_name=f"{doc_type.lower().replace(' ', '_').replace('&', 'and')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.docx",
                        mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                        use_container_width=True
                    )
            else:
                st.button("üìò DOCX (Install python-docx)", disabled=True, use_container_width=True)
        
        st.markdown('</div>', unsafe_allow_html=True)
        
        # Installation instructions
        if not REPORTLAB_AVAILABLE or not DOCX_AVAILABLE:
            with st.expander("‚ÑπÔ∏è Enable PDF/DOCX Downloads"):
                st.markdown("""
                To enable PDF and DOCX downloads, install:
                
                ```bash
                pip install reportlab python-docx
                ```
                
                Then restart the application.
                """)
        
        # Document metadata details
        with st.expander("‚ÑπÔ∏è Document Metadata & Details"):
            metadata = draft_result.get('metadata', {})
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("**Generation Details:**")
                st.json({
                    "Generated At": metadata.get('generated_at', 'N/A'),
                    "Jurisdiction": metadata.get('jurisdiction', 'General'),
                    "Template Used": metadata.get('template_used', 'N/A')
                })
            
            with col2:
                st.markdown("**Document Statistics:**")
                st.json({
                    "Word Count": draft_result.get('word_count', 0),
                    "Input Tokens": draft_result.get('input_tokens', 0),
                    "Output Tokens": draft_result.get('output_tokens', 0),
                    "Total Tokens": draft_result.get('tokens_used', 0),
                    "Processing Time": f"{draft_result.get('processing_time', 0):.2f}s"
                })
            
            if draft_result.get('clauses_included'):
                st.markdown("**Clauses Included:**")
                st.write(", ".join(draft_result['clauses_included']))
    
    else:
        st.info("üìù No documents generated yet. Fill in the requirements above and click 'Generate Document'")
        
        with st.expander("üí° Tips for Better Results"):
            st.markdown("""
            **For Best Results:**
            - Be specific about parties involved
            - Include key terms and conditions
            - Mention jurisdiction if applicable
            - Specify any special clauses needed
            - Provide context and background
            
            **Example Requirement:**
            *"Draft a service agreement between Acme Corp (service provider) and Beta Inc (client) 
            for cloud infrastructure services. Monthly fee of $5,000, 12-month term with 30-day 
            termination notice, includes SLA guarantees of 99.9% uptime, confidentiality obligations, 
            and limitation of liability capped at annual fees. Governed by California law."*
            """)

# Cleanup function
def cleanup_temp_files():
    """Clean up temporary files"""
    for file_path in st.session_state.get('temp_file_paths', []):
        if os.path.exists(file_path):
            try:
                os.remove(file_path)
                logger.info(f"Cleaned up: {file_path}")
            except Exception as e:
                logger.error(f"Cleanup error: {e}")

atexit.register(cleanup_temp_files)